# 이 문제는 높이를 브루트포스로 1부터 256까지 찾아간다. 
# 현재 높이가 목표의 높이와의 대소에 따라 인벤토리가 바뀐다.
# 이 말이 무슨말이냐면 현재 높이가 목표 높이보다 작다면 인벤토리에서 블록을 꺼내서 현재 블록에 추가해준다는 것이다.(대신 인벤토리는 감소한다.)
# 현재 높이가 목표 높이보다 크다면 필요없는 블록들을 인벤토리에 넣어줄 수 있다.(대신 현재 블록은 감소한다.)
# 여기서 입력받을 때의 초기 인벤토리 값과 추가로 인벤토리에 넣어준 값을 더해준 값이 인벤토리에서 나온 값보다 작다면 목표 높이로 땅을 고를수 없기 때문에(인벤토리에서 나온 값이 더 많으면 목표높이로 땅을 고르게 할 수 없다, 블록이 모자르다) continue를 사용해 다음 목표높이로 넘어간다.
# 시간은 인벤토리로 들어가는 작업 곱하기 2와 인벤토리에서 나오는 작업을 더한 값이다.
# 초기 시간보다 작으면 시간과 높이를 갱신해준다.
# 높이는 오름차순으로 돌기 때문에 시간이 같더라도 높이가 높은 값으로 출력이 된다. 
import sys 
N, M, B = map(int, sys.stdin.readline().split()) # 행, 열, 인벤토리 남아있는 값 입력
block = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] # 2차원 list n행으로 입력
first_time = 9999999999999999999999999999999 # 적당히 큰 시간 값
high = 0 # 높이 초기화

for i in range(257): # 높이 0-256까지
  inven_in = 0
  inven_out = 0
  for l in range(N):
    for k in range(M):
      if block[l][k] < i: # 현재 높이가 목표 높이보다 작을 때
        inven_out += (i-block[l][k]) # 땅의 높이를 고르게 하기 위한 값을 변수(인벤토리에서 꺼내는 값)에 더해준다.
      else: # 현재 높이가 목표 높이보다 클 때
        inven_in += (block[l][k]-i) # 땅의 높이를 고르게 하기 위한 값을 변수(인벤토리에서 넣어주는 값)에 더해준다.

  real_inven = inven_in + B # 실제 인벤토리 값은 넣어주는 값 + 초기에 존재하는 값
  if real_inven < inven_out: # 넣어주는 값이 빠지는 값보다 작아지면 목표 높이까지 도달 할 수가 없기 때문에 continue를 사용해 다음 높이로 이동
    continue
  
  alltime = 2 * inven_in + inven_out # 넣어주는 작업은 시간이 2배로 들고, 꺼내는 작업은 1초 걸린다.
  if alltime <= first_time: # 전체시간이 초기 시간보다 작으면 시간과 높이를 최신화해준다.
    first_time = alltime
    high = i
# 높이는 오름차순으로 입력이 되는데 시간이 같더라도 높이가 마지막까지 입력이 무조건 되기 때문에 최대 높이를 출력할수있다.
print(first_time, high)